# 객체지향 - 참조
## 복제란?
> 전자화된 시스템(컴퓨터)의 가장 중요한 특징은 `복제`입니다. 현실의 사물과 다르게 전자화된 시스템 위의 데이터를 복제 하는데는 비용이 거의 들지 않습니다.

- 예제
```js
let a = 1;
let b = a;  // a라는 값이 복제되어 b에 담겨지게 됨
b = 2;
console.log(a); // 1
```
> a = 1이고 b = a 이기 떄문에 b = 2라고 하더라도 되어도 a = 1입니다.

## 참조(reference)
- 예제
```js
let a = {'id':1};
let b = a;
b.id = 3; 
console.log(a.id);  // 3
```
> a = id 가 1인 객체가 생성되고 a라는 변수는 그 객체를 가르킵니다.  
b = a 라고 할때 객체는 b라는 값이 생성 되는것이 아닌 b는 a의 값을 참조하게 됩니다.  
그리하여 a의 값을 바꿔도 b의 값이 바뀌고 b의 값을 바꿔도 a의 값이 바뀌게되어 b.id가 3이 되게 됩니다.

- 추가예제
```js
let a = {'id':1};
let b = a;  // 똑같은 객체를 바라보게 됨
b = {'id':2};
console.log(a.id);  // 1
```
> a는 id : 1을 가르키는 객체인 것이고 b와 a가 같다고 하지만 `b는 id:2라는 새로운 객체를 생성`하여 변수 b에 할당하게 됨으로 b는 a의 id :1 을 바라보는게 아닌 b는 id :2 를 바라보게 됩니다.  
그상태에서 a.id를 콘솔로그를 찍으면 1이라는 결과가 나오게 됩니다.

> 위 예제를 비교하면`let b = a;` 에서 차이가 발생하게 됩니다.  
위 예제 원시데이터는 `a -> 1을 가르키고 b -> 1`을 가르키는데 같은 1 이 아닌 새로 복제한 1을 b는 가르키게 됩니다.
하지만 바로위 추가예제에서는 b와 a가 같은 객체를 바라보게 됩니다. 즉, `b -> id:1 <- a`형식 이게 되는 것 입니다.

## 함수와 참조
> 일종의 변수 할당이라고 할 수 있는 메소드의 매개변수는 어떻게 동작하는지 확인 해보자.

- 예제, 원시 데이터 타입을 인자로 넘겼을 때 동작 모습
```js
let a = 1;
function func (b){
    b = 2;
}
func (a);
console.log(a); // 1
```
> a = 1이고 그리고 함수의 파라미터 b의 값을 2로 받고 있습니다.
func (a)로 호출할땐 a를 호출하면서 `b = a` 인 것이고 `b = 2`이라고 하지만 위에서 `a = 1`인 상태로 `b = a일떄 복제가 되어 b = 1`이기 때문에 함수 안에서 `b 의 값을 2로 바꿔도 결과는 1`이 되게 됩니다.

- 추가 예제, 참조 데이터 타입을 인자로 넘겼을 때 동작 모습
```js
let a = {'id':1};
function func (b){
    b = {'id':2};
}
func (a);
console.log(a.id);  // 1
```
> a = {'id':1};이고 함수 a를 호출하고 `func (b)`로 `b = a;` 가 되며 함수 안에 값 b = {'id':2}; 입니다.  
b와 a가 똑같은 객체를 가르키지만 `b = {'id':2};` 함수 안에 내용으로인해서 `b와 a의 링크는 끊기게 되며` console.log(a.id);의 결과는 1이 되게 됩니다. 

- 추가 예제, 객체의 참조를 변경
```js
let a = {'id':1};
function func (b){
    b.id = 2;
}
func (a);
console.log(a.id);  // 2
```
> 이 경우엔 b = a로 같은 객체를 참조하고있고 함수 안에 내용으로 `b.id = 2;`로 같은 참조를 하고있기 때문에 a.id값도 1이 아닌 2로 바뀌게 됩니다.